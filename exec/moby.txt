#include <stdio.h>
#include <stdlib.h>
#include "list.h"


int length(LL *head) {

	int count;
	count = 0;
	while(head != NULL) {
		head = head->next;
		count++;
	}

	return count;

}


void destroy(LL *head) {

	LL *forward = head->next;

	while(head != NULL) {
		free(head);
		head = forward;
		if(forward == NULL)
			forward = NULL;
		else
			forward = forward->next;
	}
}

void print(LL *node) {

	printf("%s\n",node->command);
	
	int i;
	i = 0;
	while((strcmp(node->args[i],"")) != 0) {
		printf("%s\n",node->args[i]);		
		i++;
	}

	printf("\n");

}

void printList(LL *head) {

	while(head != NULL) {
		print(head);
		head = head->next;
	}
}

#include <stdio.h>

struct linkedList {
        char command[2048];
        char args[50][2048];
        struct linkedList *next;
};

typedef struct linkedList LL;

int length(LL *head);
void destroy(LL *head);
void print(LL *node);
void printList(LL *head);
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include "list.h"



int main() {

	LL *first = (LL *)malloc(sizeof(LL));
	//LL *second = (LL *)malloc(sizeof(LL));
	//LL *third = (LL *)malloc(sizeof(LL));

	strcpy(first->command,"cd");
	strcpy(first->args[0],"/home/nikhil/Downloads");
	first->next = NULL;

/*
	strcpy(second->command,"grep");
	strcpy(second->args[0],"ou");
	second->next = third;

		
	strcpy(third->command,"sort");
	strcpy(third->args[0],"-r");
	third->next = NULL;
*/	

	execute(first);

	destroy(first);

	return 0;
}



main: main.c list.h list.c util.h util.c
	clear;
	gcc -o main main.c list.h list.c util.h util.c


debug: main.c list.h list.c util.h util.c
	clear;
	gcc -g main.c list.h list.c util.h util.c
	gdb a.out

clean:
	rm main
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "list.h"

void prepForExec(char *Args[],LL *node) {
	
	Args[0] = node->command;
	
	int i;
	i = 0;
	while((strcmp(node->args[i],"")) != 0) {
		Args[i+1] = node->args[i];
		i++;
	}

	Args[i+1] = NULL;

	return;

}

void closeFDsingle(int fd, int pipes[][2], int pipeNum) {

        int i, j;

        for(i = 0; i < pipeNum; i++) {
                for(j = 0; j < 2; j++) {
                        if(pipes[i][j] != fd)
                                close(pipes[i][j]);
                }
        }
}

void closeFDdouble(int one, int two, int pipes[][2], int pipeNum) {

        int i, j;

        for(i = 0; i < pipeNum; i++) {
                for(j = 0; j < 2; j++) {
                        if((pipes[i][j] != one) && (pipes[i][j] != two))
                                close(pipes[i][j]);
                }
        }
}


void execute(LL *head) {


	int status;
        LL *cmd;
        cmd = head;
        pid_t pid;

        // Create all the pipes first, then spawn all the children and assign the file descriptors

        int pipeNum,listLen;
        listLen = length(head);
        pipeNum = listLen - 1;
        int pipes[pipeNum][2];

        int i;
        for(i = 0; i < pipeNum; i++)
                pipe(pipes[i]);


	 for(i = 0; i < listLen; i++) {

                //printf("i = %u\n",i); 
                switch(pid = fork()) {

                        case 0:
                                if(i == 0) { // beginning
					if(builtIn(cmd)) 
						printf("built-in action: %s\n",cmd->command);
					else {
						dup2(pipes[i][1],1);
                                        	closeFDsingle(pipes[i][1],pipes,pipeNum);
	                                        char *Args[51];
	                                        prepForExec(Args,cmd);
	                                        execvp(Args[0],Args);
	                                        perror(Args[0]);
					}
                                } else if(i == pipeNum) { // end
					if(builtIn(cmd))
						printf("built-in action: %s\n",cmd->command);
					else {
						dup2(pipes[i-1][0],0);
	                                        closeFDsingle(pipes[i-1][0],pipes,pipeNum);
	                                        char *Args[51];
	                                        prepForExec(Args,cmd);
	                                        execvp(Args[0],Args);
        	                                perror(Args[0]);
					}
                                } else { // middle
					if(builtIn(cmd))
						printf("built-in action: %s\n",cmd->command);
					else {
						dup2(pipes[i-1][0],0);
	                                        dup2(pipes[i][1],1);
						closeFDdouble(pipes[i-1][0],pipes[i][1],pipes,pipeNum);
	                                        char *Args[51];
	                                        prepForExec(Args,cmd);
	                                        execvp(Args[0],Args);
	                                        perror(Args[0]);
					}
                                }

                        default:
                                if(i < pipeNum) {
                                        close(pipes[i][1]); //close(pipes[i][0]);
                                        cmd = cmd->next;
                                }
                                break;

                        case -1:
                                perror("fork");
                                exit(1);
                }
        }


	 while((pid = wait(&status)) != -1)
                fprintf(stderr,"Process %d exits with %d\n",pid,WEXITSTATUS(status));


}



int builtIn(LL *cmd) {

	if(strcmp(cmd->command,"cd") == 0)
		return 1;
	else if (strcmp(cmd->command,"exit") == 0)
		return 1;
	else
		return 0;
}






#include <stdio.h>
#include "list.h"

void prepForExec(char *Args[], LL *node);
void closeFDsingle(int fd, int pipes[][2], int pipeNum);
void closeFDdouble(int one, int two, int pipes[][2],int pipeNum);
void execute(LL *head);
int builtIn(LL *cmd);
